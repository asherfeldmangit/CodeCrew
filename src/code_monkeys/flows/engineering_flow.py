from __future__ import annotations

"""Flow orchestrating the EngineeringTeam crew in a more explicit, event-driven way.

This is the first step towards suggestion 1: replacing the ad-hoc call in
``code_monkeys.main`` with a Flow that handles inputs, maintains state and can
be extended with richer control-flow (iterations, branching, etc.).
"""

from typing import Dict, Any
import os
import json
import re

from pydantic import BaseModel, Field
from crewai.flow.flow import Flow, listen, start

from code_monkeys.crew import EngineeringTeam

# ---------------------------------------------------------------------------
# State models
# ---------------------------------------------------------------------------

class EngineeringState(BaseModel):
    """Typed state shared across Flow steps.

    We start with a minimal schema; more fields can be added later to support
    advanced logic (e.g. per-task iterations, QA feedback, etc.).
    """

    requirements: str = ""
    project_name: str = ""
    class_name: str = ""

    # Place-holders for artefacts generated by the crew
    design_doc_path: str | None = None
    tasks_breakdown_path: str | None = None
    build_artifacts: Dict[str, str] = Field(default_factory=dict)


# ---------------------------------------------------------------------------
# Flow implementation
# ---------------------------------------------------------------------------

class EngineeringFlow(Flow[EngineeringState]):
    """High-level orchestration for the CodeMonkeys engineering agents.

    The Flow collects inputs, delegates the heavy lifting to the hierarchical
    crew, and exposes hook points for future improvements (review loops,
    conditional routing, persistence, etc.).
    """

    # ---------------------------------------------------------------------
    # 1) Collect input (non-interactive – values come from kickoff())
    # ---------------------------------------------------------------------

    @start()
    def collect_inputs(self):  # noqa: D401
        """Initial step – state is already pre-populated by Flow.kickoff().

        We only create the output directory if *project_name* was provided by the
        caller (advanced use-case). Otherwise the *propose_names* step will
        generate it.
        """

        if self.state.project_name:
            os.makedirs(f"output/{self.state.project_name}", exist_ok=True)

        return "inputs_collected"

    # ---------------------------------------------------------------------
    # 1b) Ask architect to propose project & main class names
    # ---------------------------------------------------------------------

    @listen(collect_inputs)
    def propose_names(self, _prev: Any):  # noqa: D401
        """Use the architect_agent to suggest *project_name* and *class_name*.

        The agent is prompted to reply with a JSON document containing
        {"project_name": "...", "class_name": "..."}. We fall back to a
        deterministic slug if parsing fails.
        """

        if self.state.project_name and self.state.class_name:
            # Names were provided explicitly in kickoff; skip generation.
            return "names_preexisting"

        # Instantiate a standalone architect_agent (no crew yet)
        architect = EngineeringTeam().architect_agent()

        prompt = (
            "You are a senior software architect. Given the product requirements "
            "below, propose a concise Python *package* name (PascalCase, no spaces) "
            "and a main *class* name (also PascalCase). Reply strictly in JSON with "
            "keys 'project_name' and 'class_name'.\n\n"
            f"Requirements:\n{self.state.requirements}\n"
        )

        # We attempt to call the agent; if any exception occurs, we have a fallback.
        try:
            response = architect.chat(prompt)  # type: ignore[attr-defined]
            data = json.loads(response)
            self.state.project_name = str(data["project_name"]).strip()
            self.state.class_name = str(data["class_name"]).strip()
        except Exception:  # pragma: no cover – robust fallback
            # Fallback: derive names from requirements heuristic.
            slug = re.sub(r"[^A-Za-z]+", " ", self.state.requirements).title().replace(" ", "")
            self.state.project_name = slug if slug else "GeneratedProject"
            self.state.class_name = self.state.project_name

        # Ensure an output directory now that we have the project name
        os.makedirs(f"output/{self.state.project_name}", exist_ok=True)

        return "names_proposed"

    # ---------------------------------------------------------------------
    # 2) Run the existing EngineeringTeam crew
    # ---------------------------------------------------------------------

    @listen(propose_names)
    def run_engineering_crew(self, _previous_step_output: Any):  # noqa: D401
        """Kick off the existing EngineeringTeam hierarchical crew."""

        inputs = {
            "requirements": self.state.requirements,
            "project_name": self.state.project_name,
            "class_name": self.state.class_name,
            "project_name_lower": self.state.project_name.lower(),
        }

        # The crew returns a Result object with a `.raw` attribute (by default)
        result = EngineeringTeam().crew().kickoff(inputs=inputs)
        # Store artefacts or summaries if needed. For now we keep raw output.
        self.state.build_artifacts["crew_output"] = result.raw if hasattr(result, "raw") else str(result)

        return "engineering_complete"


# ---------------------------------------------------------------------------
# Convenience wrappers – similar to the pattern in other flows/examples
# ---------------------------------------------------------------------------

def kickoff(**inputs):
    """Programmatic entry-point for running the EngineeringFlow.

    Example usage:
        kickoff(requirements="Create Tic-Tac-Toe", project_name="TicTacToe", class_name="T3Game")
    """

    flow = EngineeringFlow()
    # Pass inputs to the Flow; these propagate to the collect_inputs step.
    flow_output = flow.kickoff(inputs=inputs)
    return flow_output


def plot(filename: str = "engineering_flow") -> None:
    """Generate an HTML visualization of the flow graph."""

    flow = EngineeringFlow()
    flow.plot(filename) 