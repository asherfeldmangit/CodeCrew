from __future__ import annotations

"""Flow orchestrating the EngineeringTeam crew in a more explicit, event-driven way.

This is the first step towards suggestion 1: replacing the ad-hoc call in
``code_monkeys.main`` with a Flow that handles inputs, maintains state and can
be extended with richer control-flow (iterations, branching, etc.).
"""

from typing import Dict, Any
import os

from pydantic import BaseModel, Field
from crewai.flow.flow import Flow, listen, start

from code_monkeys.crew import EngineeringTeam

# ---------------------------------------------------------------------------
# State models
# ---------------------------------------------------------------------------

class EngineeringState(BaseModel):
    """Typed state shared across Flow steps.

    We start with a minimal schema; more fields can be added later to support
    advanced logic (e.g. per-task iterations, QA feedback, etc.).
    """

    requirements: str = ""
    project_name: str = ""
    class_name: str = ""

    # Place-holders for artefacts generated by the crew
    design_doc_path: str | None = None
    tasks_breakdown_path: str | None = None
    build_artifacts: Dict[str, str] = Field(default_factory=dict)


# ---------------------------------------------------------------------------
# Flow implementation
# ---------------------------------------------------------------------------

class EngineeringFlow(Flow[EngineeringState]):
    """High-level orchestration for the CodeMonkeys engineering agents.

    The Flow collects inputs, delegates the heavy lifting to the hierarchical
    crew, and exposes hook points for future improvements (review loops,
    conditional routing, persistence, etc.).
    """

    # ---------------------------------------------------------------------
    # 1) Collect input (non-interactive – values come from kickoff())
    # ---------------------------------------------------------------------

    @start()
    def collect_inputs(self, requirements: str, project_name: str, class_name: str):  # noqa: D401
        """Populate initial state from kickoff() arguments."""

        self.state.requirements = requirements
        self.state.project_name = project_name
        self.state.class_name = class_name

        # Ensure a dedicated output directory for the project exists
        os.makedirs(f"output/{project_name}", exist_ok=True)
        return "inputs_collected"

    # ---------------------------------------------------------------------
    # 2) Run the existing EngineeringTeam crew
    # ---------------------------------------------------------------------

    @listen(collect_inputs)
    def run_engineering_crew(self, _previous_step_output: Any):  # noqa: D401
        """Kick off the existing EngineeringTeam hierarchical crew."""

        inputs = {
            "requirements": self.state.requirements,
            "project_name": self.state.project_name,
            "class_name": self.state.class_name,
        }

        # The crew returns a Result object with a `.raw` attribute (by default)
        result = EngineeringTeam().crew().kickoff(inputs=inputs)
        # Store artefacts or summaries if needed. For now we keep raw output.
        self.state.build_artifacts["crew_output"] = result.raw if hasattr(result, "raw") else str(result)

        return "engineering_complete"


# ---------------------------------------------------------------------------
# Convenience wrappers – similar to the pattern in other flows/examples
# ---------------------------------------------------------------------------

def kickoff(**inputs):
    """Programmatic entry-point for running the EngineeringFlow.

    Example usage:
        kickoff(requirements="Create Tic-Tac-Toe", project_name="TicTacToe", class_name="T3Game")
    """

    flow = EngineeringFlow()
    # Pass inputs to the Flow; these propagate to the collect_inputs step.
    flow_output = flow.kickoff(inputs=inputs)
    return flow_output


def plot(filename: str = "engineering_flow") -> None:
    """Generate an HTML visualization of the flow graph."""

    flow = EngineeringFlow()
    flow.plot(filename) 